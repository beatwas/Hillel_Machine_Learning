"""
Завдання:

1. Знайти в датасеті таргет та видалити цю колонку з датасету (видаляти за індексом)
2. Перетворити колонки, що залишились в 2D масив (або впевнитись, що це уже 2D масив)
3. Порахувати mean, median, standard deviation для 1-ї колонки
4. Вставити 20 значень np.nan на випадкові позиції в масиві (при використанні звичайного рандому можуть накластись
    позиції, тому знайти рішення, яке гарантує 20 унікальних позицій)
5. Знайти позиції вставлених значень np.nan в 1-й колонці
6. Відфільтрувати массив за умовою: значення в 3-й колонці > 1.5 та значения в 1-й колонці < 5.0
7. Замінити всі значення np.nan на 0
8. Порахувати всі унікальні значення в массиві та вивести їх разом із кількісю
9. Розбити масив по горизонталі на 2 рівні частини (не використовувати абсолютні числа, мають бути два массиви по
    4 колонки)
10.Відсортувати обидва массиви по 1-й колонці: 1-й за збільшенням, 2-й за зменшенням
11.Зібрати обидва массиви в одне ціле
12.Знайти найбільш часто повторюване значення в массиві
13.Написати функцію, яка б множила всі значення в колонці, які менше середнього значения в цій колонці, на 2, і ділила
    інші значення на 4.
14.Застосувати отриману функцію до 3-ї колонки
"""
from statistics import mode

import numpy as np


#   1. Знайти в датасеті таргет та видалити цю колонку з датасету (видаляти за індексом)
my_arr = np.loadtxt('iris.data', delimiter=',', usecols=(0, 1, 2, 3))


#   3. Порахувати mean, median, standard deviation для 1-ї колонки
print(f'Mean: {np.round(np.mean(my_arr[:, 0]), 2)}\n'
      f'Median: {np.round(np.median(my_arr[:, 0]), 2)}\n'
      f'Standard deviation: {np.round(np.std(my_arr[:, 0]), 2)}')

#   4. Вставити 20 значень np.nan на випадкові позиції в масиві (при використанні звичайного рандому можуть накластись
#     позиції, тому знайти рішення, яке гарантує 20 унікальних позицій)
my_arr.ravel()[np.random.choice(my_arr.size, 20, replace=False)] = np.nan


#   5. Знайти позиції вставлених значень np.nan в 1-й колонці
nan_in_fcol = np.argwhere(np.isnan(my_arr[:, 0]))

print('Rows with np.nan on first place:')
print(nan_in_fcol)


#   6. Відфільтрувати массив за умовою: значення в 3-й колонці > 1.5 та значения в 1-й колонці < 5.0
arr6 = my_arr[(my_arr[:, 2] > 1.5) & (my_arr[:, 0] < 5.0)]

print('Filtered array by the condition: values in the 3rd column > 1.5 and values in the 1st column < 5.0:')
print(arr6)


#   7. Замінити всі значення np.nan на 0
my_arr[np.isnan(my_arr)] = 0


#   8. Порахувати всі унікальні значення в массиві та вивести їх разом із кількісю
unique, counts = np.unique(my_arr, return_counts=True)

print('Unique values in array:')
print(np.asarray((unique, counts)).T)


#   9. Розбити масив по горизонталі на 2 рівні частини (не використовувати абсолютні числа, мають бути два массиви по
#     4 колонки)
split_arr = np.array_split(my_arr, 2)


#   10.Відсортувати обидва массиви по 1-й колонці: 1-й за збільшенням, 2-й за зменшенням
split_arr[0] = split_arr[0][split_arr[0][:, 0].argsort()]
split_arr[1] = split_arr[1][split_arr[1][:, 0].argsort()[::-1]]


#   11.Зібрати обидва массиви в одне ціле
new_arr = np.vstack(split_arr)


#   12.Знайти найбільш часто повторюване значення в массиві
flat_array = my_arr.flatten()
print('Most frequently repeated value in array: ', mode(flat_array))


#   13.Написати функцію, яка б множила всі значення в колонці, які менше середнього значения в цій колонці, на 2,
#     і ділила інші значення на 4.
def func_13(col_numb):
    col_numb -= 1
    arr_mean = np.mean(my_arr[:, col_numb])
    h_arr = np.empty(0, float)

    for i in my_arr[:, col_numb]:
        if i < arr_mean:
            h_arr = np.append(h_arr, 2)
        else:
            h_arr = np.append(h_arr, 0.25)

    my_arr[:, col_numb] = np.multiply(my_arr[:, col_numb], h_arr)


#   14.Застосувати отриману функцію до 3-ї колонки
func_13(3)
